name: Production Release

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened, closed]
  schedule:
    # Production jobs run at specific times
    - cron: '0 6 * * 1-5'  # 6 AM UTC on weekdays
    - cron: '0 18 * * 1-5' # 6 PM UTC on weekdays
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
          - hotfix
      skip_tests:
        description: 'Skip tests (emergency only)'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: ${{ vars.PYTHON_VERSION || '3.9' }}
  ENVIRONMENT: 'production'

jobs:
  pre-release-validation:
    name: Pre-Release Validation
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action != 'closed'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Validate PR source
      run: |
        echo "::group::PR Validation"
        if [[ "${{ github.head_ref }}" != "uat" ]]; then
          echo "‚ùå PRs to main must come from UAT branch"
          exit 1
        fi
        echo "‚úÖ PR from UAT branch validated"
        echo "::endgroup::"
        
    - name: Check release notes
      run: |
        echo "::group::Release Notes Check"
        if [ ! -f "RELEASE_NOTES.md" ]; then
          echo "‚ùå RELEASE_NOTES.md is required"
          exit 1
        fi
        echo "‚úÖ Release notes found"
        echo "::endgroup::"

  final-tests:
    name: Final Test Suite
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && !github.event.inputs.skip_tests)
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements-dev.txt
        
    - name: Run final test suite
      run: |
        echo "::group::Production Test Suite"
        pytest -v --tb=short
        echo "‚úÖ All tests passed"
        echo "::endgroup::"
        
    - name: Security audit
      run: |
        echo "::group::Final Security Audit"
        bandit -r src/ -ll
        echo "‚úÖ Security audit passed"
        echo "::endgroup::"

  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: final-tests
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    outputs:
      version: ${{ steps.version.outputs.version }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Get version
      id: version
      run: |
        # Get the last tag
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Last tag: $LAST_TAG"
        
        # Determine new version based on commit messages or input
        if [[ "${{ github.event.inputs.release_type }}" == "major" ]]; then
          NEW_VERSION=$(echo $LAST_TAG | awk -F. '{print "v" $1+1 ".0.0"}' | sed 's/vv/v/')
        elif [[ "${{ github.event.inputs.release_type }}" == "minor" ]]; then
          NEW_VERSION=$(echo $LAST_TAG | awk -F. '{print $1 "." $2+1 ".0"}')
        else
          NEW_VERSION=$(echo $LAST_TAG | awk -F. '{print $1 "." $2 "." $3+1}')
        fi
        
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "New version: $NEW_VERSION"
        
    - name: Create Git tag
      run: |
        git config user.name "Release Bot"
        git config user.email "release-bot@example.com"
        git tag -a ${{ steps.version.outputs.version }} -m "Release ${{ steps.version.outputs.version }}"
        git push origin ${{ steps.version.outputs.version }}
        
    - name: Generate changelog
      id: changelog
      run: |
        echo "## Changelog" > CHANGELOG_TEMP.md
        echo "" >> CHANGELOG_TEMP.md
        git log --pretty=format:"- %s (%h)" $(git describe --tags --abbrev=0 HEAD^)..HEAD >> CHANGELOG_TEMP.md
        
    - name: Create GitHub Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.version.outputs.version }}
        release_name: Release ${{ steps.version.outputs.version }}
        body_path: CHANGELOG_TEMP.md
        draft: false
        prerelease: false

  production-deployment:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: create-release
    environment:
      name: production
      url: https://prod.example.com
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ needs.create-release.outputs.version }}
        
    - name: Deploy to production
      run: |
        echo "::group::Production Deployment"
        echo "Deploying version ${{ needs.create-release.outputs.version }} to production..."
        echo "Environment: Production"
        echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
        # Add actual deployment logic here
        echo "‚úÖ Production deployment successful"
        echo "::endgroup::"
        
    - name: Verify deployment
      run: |
        echo "::group::Deployment Verification"
        echo "Running production health checks..."
        # Add health check logic
        echo "‚úÖ All systems operational"
        echo "::endgroup::"
        
    - name: Update deployment status
      uses: actions/github-script@v6
      with:
        script: |
          const deployment = await github.rest.repos.createDeployment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: '${{ needs.create-release.outputs.version }}',
            environment: 'production',
            auto_merge: false,
            required_contexts: [],
            description: 'Production release ${{ needs.create-release.outputs.version }}'
          });
          
          await github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: deployment.data.id,
            state: 'success',
            environment_url: 'https://prod.example.com',
            description: 'Deployment successful'
          });

  scheduled-jobs:
    name: Scheduled Production Jobs
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: main
        
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Run scheduled job
      run: |
        echo "::group::Scheduled Job Execution"
        echo "Running scheduled production job at $(date -u +%Y-%m-%dT%H:%M:%SZ)"
        
        # Simulate a batch job
        python -c "
        from src.calculator import Calculator
        import random
        
        calc = Calculator()
        print('Starting batch calculation job...')
        
        # Simulate batch processing
        for i in range(10):
            a = random.randint(1, 100)
            b = random.randint(1, 100)
            result = calc.add(a, b)
            print(f'Processed: {a} + {b} = {result}')
        
        print('Batch job completed successfully!')
        print(f'Total operations: {len(calc.get_history())}')
        "
        
        echo "‚úÖ Scheduled job completed"
        echo "::endgroup::"

  release-notification:
    name: Release Notification
    runs-on: ubuntu-latest
    needs: [production-deployment]
    if: always()
    
    steps:
    - name: Send release notification
      run: |
        if [ "${{ needs.production-deployment.result }}" == "success" ]; then
          echo "üéâ Production Release Successful!"
          echo "Version: ${{ needs.create-release.outputs.version }}"
          echo "Status: Deployed"
          # Add notification logic (email, Slack, Teams, etc.)
          
          # Example notification payload
          cat << EOF > notification.json
          {
            "version": "${{ needs.create-release.outputs.version }}",
            "status": "success",
            "environment": "production",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "message": "Production release ${{ needs.create-release.outputs.version }} deployed successfully!"
          }
          EOF
          
          echo "Notification sent to all stakeholders"
        else
          echo "‚ùå Production Release Failed!"
          echo "Version: ${{ needs.create-release.outputs.version }}"
          echo "Status: Failed"
          # Add failure notification logic
        fi
        
    - name: Update release dashboard
      run: |
        echo "Updating release dashboard..."
        # Add dashboard update logic
        echo "Dashboard updated with latest release information"

  rollback-preparation:
    name: Prepare Rollback Plan
    runs-on: ubuntu-latest
    needs: production-deployment
    
    steps:
    - name: Create rollback instructions
      run: |
        echo "::group::Rollback Plan"
        echo "Rollback instructions for version ${{ needs.create-release.outputs.version }}"
        echo ""
        echo "To rollback to previous version:"
        echo "1. Run: git checkout $(git describe --tags --abbrev=0 HEAD^)"
        echo "2. Deploy using emergency workflow"
        echo "3. Notify all stakeholders"
        echo ""
        echo "Rollback plan created and stored"
        echo "::endgroup::" 